// The `prelude` module provides a convenient way to import a number
// of common dependencies at once. This can be useful if you are working
// with multiple parts of the library and want to avoid having
// to import each dependency individually.
use ethers::prelude::*;

mod uniswap_v2_pair;

// NOTE: requires multi-thread feature on `tokio`
// we can customize as well in terms of no. of CPUs allotted for the work
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    dotenv::from_path("./.env").expect("Failed in loading the file");
    let rpc_url = std::env::var("SEPOLIA_RPC_URL").expect("Please check if it's empty");

    let client: Provider<Http> =
        Provider::<Http>::try_from(rpc_url).expect("Failed to connect w RPC");
    // get node info as struct
    // let node_info = provider.node_info().await?;
    // println!("Node info: {:?}", node_info); // for infura node, it's not available

    // get block number
    let current_block_number: U64 = client.get_block_number().await?;
    println!("current block number: {current_block_number}");

    // define address as
    let addr = "0x0370D871f1D4B256E753120221F3Be87A40bd246".parse::<Address>()?;
    // get current ETH balance of an account
    let wei_bal = client
        .get_balance(addr, Some(current_block_number.into()))
        .await?;
    // get the decimal value when divided by 10^18
    let eth_bal = wei_bal.as_usize() as f64 / 1e18;
    println!("balance: {} Wei", wei_bal);
    println!("balance: {eth_bal:.18} ETH");

    // TODO: get nonce of an account
    let nonce = client
        .get_transaction_count(addr, Some(current_block_number.into()))
        .await?;
    println!("nonce: {}", nonce);

    // recommended to not prefix w "0x"
    let priv_key =
        "d013bd87f33f1b38a895d549c6696e53d71cf44c29156452a48917923a0fa7d3".parse::<Bytes>()?;
    // TODO: get address from private key
    // let address = client.import_raw_key(priv_key, "".to_string()).await?;
    // println!("{}", address);

    // TODO: Connect to a contract using Rust bindings generated by Foundry tool

    // TODO: send a transaction

    // TODO: call a function

    // TODO: list the functions of a contract
    let default_sender = client.default_sender().unwrap_or_default();
    println!("{}", default_sender); // if None, then returns default

    // TODO: check if a function exists in a contract

    // M-1: in order to use this, just remove `#[tokio::main]` annotation
    let mid_price = uniswap_v2_pair::main().await?;
    println!("ETH/USDT price: {mid_price:.2}");

    // M-2: TODO: Use the `#[tokio::main]` attribute and then just spawn a new runtime here like this:
    // Also, collect the output into a variable

    Ok(())
}
